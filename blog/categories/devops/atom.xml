<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: devops | Bitácora]]></title>
  <link href="http://mcoam.github.io/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://mcoam.github.io/"/>
  <updated>2015-11-12T18:52:51-03:00</updated>
  <id>http://mcoam.github.io/</id>
  <author>
    <name><![CDATA[Miguel Angel Coa Morales]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ansible: Configurando volúmen de datos HSM en Zimbra]]></title>
    <link href="http://mcoam.github.io/blog/2015/11/12/ansible-configurando-volumen-de-datos-hsm-en-zimbra/"/>
    <updated>2015-11-12T18:34:00-03:00</updated>
    <id>http://mcoam.github.io/blog/2015/11/12/ansible-configurando-volumen-de-datos-hsm-en-zimbra</id>
    <content type="html"><![CDATA[<p>El siguiente <code>Playbook</code> permite configurar un nuevo volúmen para datos (store) en un servidor Zimbra NE.</p>

<h2>```objc</h2>

<ul>
<li>hosts: ne_mailbox
remote_user: root
vars:
      zmvolume: &ldquo;/opt/zimbra/bin/zmvolume&rdquo;
      zmhsm: &ldquo;/opt/zimbra/bin/zmhsm&rdquo;
      zmprov: &ldquo;/opt/zimbra/bin/zmprov&rdquo;
      hsm_name: &ldquo;hsm02&rdquo;
      hsm_id: &ldquo;4&rdquo; # check id zmvolume -l |grep -B1 hsm02
      path: &ldquo;/opt/zimbra/store_hsm_02/&rdquo;
      policy_option: &ldquo; &lsquo;message,document,task,appointment,contact:before:-1month is:anywhere&rsquo; &rdquo;
tasks:

<pre><code>  - name: "Configura volumen HSM como volumen secundario"
    command: "{ { zmvolume } } -a -name  -c true -t secondaryMessage -p { { path } }"

  - name: "Activamos nuevo volumen para manejar data"
    command: "{ { zmvolume } } -sc -id { { hsm_id } } " 

  - name: "Configuramos politica HSM: Todo por sobre 1 mes se mueve al nuevo volumen"
    command: "{ { zmprov } } ms { { ansible_fqdn } } zimbraHsmPolicy { { policy_option } }"

  - name: "Arrancamos el proceso para mover correos al nuevo HSM"
    command: "{ { zmhsm } } -t"
</code></pre>

<p><code>``
&lt;b&gt;Donde:&lt;br&gt;&lt;/b&gt;
</code>path: &ldquo;/opt/zimbra/store_hsm_02/&rdquo;<code>: Corresponde al punto de montaje del nuevo recurso HSM.&lt;br&gt;
</code>hsm_id: 4"<code>: Corresponde al ID que le asigna Zimbra al nuevo volúmen (disco).&lt;br&gt;
</code>hsm_name: hsm02`: Corresponde al nombre que le colocamos al recurso HSM.<br></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ansible: Trabajando con volumenes lógicos PV/VG/LV en Linux]]></title>
    <link href="http://mcoam.github.io/blog/2015/10/28/ansible-trabajando-con-volumenes-pv-slash-vg-slash-lv/"/>
    <updated>2015-10-28T23:52:00-03:00</updated>
    <id>http://mcoam.github.io/blog/2015/10/28/ansible-trabajando-con-volumenes-pv-slash-vg-slash-lv</id>
    <content type="html"><![CDATA[<p>Ansible cuenta con un módulos para la gestión de discos en Linux los cuales no permiten administrar nuestros volúmenes.
En el siguiente ejemplo, se crea un volumen sobre un disco <code>/dev/sdf1</code> y que será configurado como volumen lógico y finalmente montado para los backup que realiza un servidor de correos Zimbra.</p>

<h2>```objc</h2>

<ul>
<li><p>hosts: ne_mailbox
vars:
      disk_name: &ldquo;/dev/sdf1&rdquo;
      filesystem: &ldquo;ext4&rdquo;
      vg_name: &ldquo;zimbra_data&rdquo;
      lv_size: &ldquo;100%FREE&rdquo; #ocupar todo el espacio libre del VG zimbra_data
      lv_name: &ldquo;backup&rdquo;
      path: &ldquo;/opt/zimbra/backup&rdquo;
      user: &ldquo;zimbra&rdquo;
tasks:</p>

<pre><code>  - name: "Crear el PV sobre el disco nuevo"
    command: pvcreate 

  - name: "Crear nuevo VG"
    lvg: vg=\{\{ vg_name \}\} pvs=\{\{ disk_name \}\}

  - name: "Crear nuevo volumen LVM"
    lvol: vg=\{\{ vg_name \}\} lv=\{\{ lv_name \}\} size=\{\{ lv_size \}\}
    tags: crea_lv

  - name: "Formateo de unidad LVM"
    filesystem: fstype=\{\{ filesystem \}\} dev=/dev/\{\{ vg_name \}\}/\{\{ lv_name \}\}
    tags: formatea_lv

  - name: "Montar disco"
    mount: name=\{\{ path \}\} src=/dev/\{\{ vg_name \}\}/\{\{ lv_name \}\} fstype=\{\{ filesystem \}\} state=mounted
    tags: monta_lv

  - name: "Permisos directorio backup"
    file: path=\{\{ path \}\} state=directory mode=0755 owner=\{\{ user \}\} group=\{\{ user \}\}
    tags: permisos_directorio
</code></pre>

<p>```</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jugando Con Docker]]></title>
    <link href="http://mcoam.github.io/blog/2014/10/02/jugando-con-docker/"/>
    <updated>2014-10-02T16:01:00-03:00</updated>
    <id>http://mcoam.github.io/blog/2014/10/02/jugando-con-docker</id>
    <content type="html"><![CDATA[<h4>Imagenes, Contenedores y Capas con Docker</h4>

<p>Al momento de empezar a trabajar con Docker aparecen varios items que si bien no son nuevos en la virtualización tradicional (mediante hypervisores) de la forma que los trabaja Docker tienen un valor agregado no por si mismos sino por la suma de todos a la vez.</p>

<h4>Capas en Docker</h4>

<p>Las capas en Docker son los <i>bloques</i> en donde se van almacenando todos los cambios que puede tener un contenedor (Ej. instalación de paquetes, update del SO, etc) por cada cambio que se realiza en el contenedor se crea una capa nueva de escritura que va solapando las capas anteriores que quedan de solo lectura, es por ello que una capas al momento en que trabajamos con ella.</p>

<h4>Docker image  Images never change once they are created.  Images can be linked.  A image that is stacked on another image can be referred to in a child parent analogy with the lower image being the parent.  The bottommost image is referred to as the base image and has no parent image.</h4>

<p>A docker container – When you start a container you reference an image.  Docker pulls the required image and pulls the images parent image.  It continues to pull the parent images until it reaches the base image.  In addition, it creates a read-write layer for changes to be stored in when the container is running.  All of these layers as well as other container configuration information is stored in the container.</p>

<p>Lo primero es crear el archivo Dockerfile con el siguiente contenido
```ruby</p>

<h1>Version: 0.0.2</h1>

<p>From centos:latest
MAINTAINER Miguel Coa &ldquo;<a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#109;&#99;&#x6f;&#97;&#64;&#x65;&#120;&#97;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">&#x6d;&#99;&#111;&#97;&#64;&#x65;&#x78;&#x61;&#x6d;&#112;&#108;&#101;&#46;&#x63;&#111;&#x6d;</a>&rdquo;</p>

<h1>RUN apt-get update</h1>

<p>RUN yum install httpd -y
RUN echo &lsquo;Hello world&rsquo; > /var/www/html/index.html
CMD service httpd start</p>

<p>EXPOSE 80
<code>
Lo anterior va a crear un contenedor en centos &lt;i&gt;latest&lt;/i&gt;, le instalará apache, creará el index.html y dejara el servicio corriendo. Una vez que tengamos creado el Dockerfile, lanzamos el comando para crear el contenedor.
</code>ruby
[root@vagrant-centos7 static_web]# docker build -t=&ldquo;mcoa01/static_web:v2&rdquo; .
Uploading context  2.56 kB
Uploading context
Step 0 : From centos:latest
 &mdash;&ndash;> 87e5b6b3ccc1
Step 1 : MAINTANER Miguel Coa &ldquo;<a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#x6d;&#x63;&#x6f;&#97;&#64;&#x65;&#120;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#109;">&#109;&#x63;&#111;&#x61;&#64;&#x65;&#x78;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#111;&#109;</a>&rdquo;</p>

<h1>Skipping unknown instruction MAINTANER</h1>

<p>Step 2 : RUN yum install httpd -y
 &mdash;&ndash;> Using cache
 &mdash;&ndash;> 9ed85d674aab
Step 3 : RUN echo &lsquo;Hi, I am in you container&rsquo; > /var/www/html/index.html
 &mdash;&ndash;> Using cache
 &mdash;&ndash;> a7cac0dce7d7
Step 4 : CMD service httpd start
 &mdash;&ndash;> Using cache
 &mdash;&ndash;> 72e4df843d86
Step 5 : CMD service sshd start
 &mdash;&ndash;> Running in 475c04052b5e
 &mdash;&ndash;> 88515c279ac0
Removing intermediate container 475c04052b5e
Step 6 : EXPOSE 80
 &mdash;&ndash;> Running in 5b3b8cc184ed
 &mdash;&ndash;> e080d67b10f4
Removing intermediate container 5b3b8cc184ed
Successfully built e080d67b10f4
<code>
Y vemos la imagen creada
</code>ruby
[root@vagrant-centos7 static_web]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
mcoa01/static_web   v2                  e080d67b10f4        12 minutes ago      321.8 MB
```</p>

<h4>Verificando nuestra imagen</h4>

<h4>Creando el contenedor a partir de la imagen creada</h4>

<p>Creando el contenedor
<code>ruby
[root@vagrant-centos7 static_web]# docker run -t -i -d -p 10.10.0.50:8080:80 --name static_web  mcoa01/static_web:v3  /bin/bash
0501489ccabc4ace605069fa0de4ade00bf9720913b137248650c66d17ce25b5
</code>
Listamos los contenedores
<code>ruby
[root@vagrant-centos7 static_web]# docker ps -a
CONTAINER ID        IMAGE                  COMMAND             CREATED             STATUS              PORTS                     NAMES
0501489ccabc        mcoa01/static_web:v3   /bin/bash           2 seconds ago       Up 2 seconds        10.10.0.50:8080-&gt;80/tcp   static_web   
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Path Global para todos los Execs en Puppet]]></title>
    <link href="http://mcoam.github.io/blog/2014/07/24/path-global-para-todos-los-execs-en-puppet/"/>
    <updated>2014-07-24T14:37:00-04:00</updated>
    <id>http://mcoam.github.io/blog/2014/07/24/path-global-para-todos-los-execs-en-puppet</id>
    <content type="html"><![CDATA[<p>En Puppet si tenemos varios <code>Exec</code> para ejecutar comandos del sistema operativo podemos configurar el atributo <code>path</code> de forma global dentro del <code>site.pp</code> y con ello evitamos repetir código.
<code>ruby
exec { "restart-dns":
command =&gt; "service named restart"
creates =&gt; "/var/named",
refreshonly =&gt; true
}
</code>
site.pp</li>
<code>ruby
Exec { path =&gt; [ "/bin/", "/sbin/" , "/usr/bin/", "/usr/sbin/" ] }
</code></p>
]]></content>
  </entry>
  
</feed>
