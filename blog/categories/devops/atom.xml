<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: devops | Bitácora]]></title>
  <link href="http://mcoam.github.io/blog/categories/devops/atom.xml" rel="self"/>
  <link href="http://mcoam.github.io/"/>
  <updated>2015-11-12T18:29:56-03:00</updated>
  <id>http://mcoam.github.io/</id>
  <author>
    <name><![CDATA[Miguel Angel Coa Morales]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ansible: Trabajando con volumenes lógicos PV/VG/LV en Linux]]></title>
    <link href="http://mcoam.github.io/blog/2015/10/28/ansible-trabajando-con-volumenes-pv-slash-vg-slash-lv/"/>
    <updated>2015-10-28T23:52:00-03:00</updated>
    <id>http://mcoam.github.io/blog/2015/10/28/ansible-trabajando-con-volumenes-pv-slash-vg-slash-lv</id>
    <content type="html"><![CDATA[<p>Ansible cuenta con un módulos para la gestión de discos en Linux los cuales no permiten administrar nuestros volúmenes.
En el siguiente ejemplo, se crea un volumen sobre un disco <code>/dev/sdf1</code> y que será configurado como volumen lógico y finalmente montado para los backup que realiza un servidor de correos Zimbra.</p>

<h2>```objc</h2>

<ul>
<li><p>hosts: ne_mailbox
vars:
      disk_name: &ldquo;/dev/sdf1&rdquo;
      filesystem: &ldquo;ext4&rdquo;
      vg_name: &ldquo;zimbra_data&rdquo;
      lv_size: &ldquo;100%FREE&rdquo; #ocupar todo el espacio libre del VG zimbra_data
      lv_name: &ldquo;backup&rdquo;
      path: &ldquo;/opt/zimbra/backup&rdquo;
      user: &ldquo;zimbra&rdquo;
tasks:</p>

<pre><code>  - name: "Crear el PV sobre el disco nuevo"
    command: pvcreate 

  - name: "Crear nuevo VG"
    lvg: vg=\{\{ vg_name \}\} pvs=\{\{ disk_name \}\}

  - name: "Crear nuevo volumen LVM"
    lvol: vg=\{\{ vg_name \}\} lv=\{\{ lv_name \}\} size=\{\{ lv_size \}\}
    tags: crea_lv

  - name: "Formateo de unidad LVM"
    filesystem: fstype=\{\{ filesystem \}\} dev=/dev/\{\{ vg_name \}\}/\{\{ lv_name \}\}
    tags: formatea_lv

  - name: "Montar disco"
    mount: name=\{\{ path \}\} src=/dev/\{\{ vg_name \}\}/\{\{ lv_name \}\} fstype=\{\{ filesystem \}\} state=mounted
    tags: monta_lv

  - name: "Permisos directorio backup"
    file: path=\{\{ path \}\} state=directory mode=0755 owner=\{\{ user \}\} group=\{\{ user \}\}
    tags: permisos_directorio
</code></pre>

<p>```</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Path Global para todos los Execs en Puppet]]></title>
    <link href="http://mcoam.github.io/blog/2014/07/24/path-global-para-todos-los-execs-en-puppet/"/>
    <updated>2014-07-24T14:37:00-04:00</updated>
    <id>http://mcoam.github.io/blog/2014/07/24/path-global-para-todos-los-execs-en-puppet</id>
    <content type="html"><![CDATA[<p>En Puppet si tenemos varios <code>Exec</code> para ejecutar comandos del sistema operativo podemos configurar el atributo <code>path</code> de forma global dentro del <code>site.pp</code> y con ello evitamos repetir código.
<code>ruby
exec { "restart-dns":
command =&gt; "service named restart"
creates =&gt; "/var/named",
refreshonly =&gt; true
}
</code>
site.pp</li>
<code>ruby
Exec { path =&gt; [ "/bin/", "/sbin/" , "/usr/bin/", "/usr/sbin/" ] }
</code></p>
]]></content>
  </entry>
  
</feed>
